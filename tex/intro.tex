\secly{Введение}

\F\ --- самый минимально-возможный язык программирования, на котором можно
что-то писать. Он не является языком высокого уровня, скорее это
платформенно-независимый ассемблер \term{виртуальной стековой машины}, но с
возможностями неограниченного расширения.

Даже в отличие от ассемблера, \F\ имеет на порядок более простую реализацию.
Ниже перечислен набор компонентов, \emph{обязательных для любого языка
программирования}. Если вы пишете свой язык, вы не сможете убрать какой-то из
них, а \F\ показывает как можно их реализовать в самом примитивном варианте.

\begin{description}
    \item[стек данных]\ref{dstack}\ очень интенсивно используется для
    промежуточного хранения данных на каждой операции\note{горячая память}
    \item[стек возвратов]\ref{rstack}\ из вложенных вызовов функций\note{\F\
    использует для хранения рабочих данных и адресов возвратов \emph{два
    отдельных стека}, другие языки используют один смешанный стек, или
    аппаратный стек процессоров который используют низкоуровневые языки типа
    \ci}
    \item[определение новых операций]\ref{compile}\ через
    существующие\note{функции}
    \item[команды] языковой машины: базовый набор операций языка
    \item[память]\ref{memory}\ для хранения данных, и
    \item[аллокатор]\ref{alloc}\ для её выделения динамически, в процессе
    работы программы
    \item[словарь]\ref{voc}\ ассоциативный массив, хранящий соответствие
    \term{имени} и \term{значения переменной}; там же хранятся определения
    функций, которые адресуются по своим именам при ручном запуске команд, и
    компиляции \ref{compile}
    \item[парсер синтаксиса]\ref{syntax}\ входного языка (программирования)
\end{description}

\textbf{Задача этой книги\ --- показать язык \F\ как концепцию}, без излишних
деталей. Поэтому мы не будем рассматривать \emph{классический \F}, c прямой
побайтовой адресацией памяти целыми числами, работой со структурами данных через
смещения в памяти, и аварийным завершением работы при любой ошибке в коде,
разрушающей стек, или адресующей неправильный адрес. Эти проблемы не только
полностью убили классический \F\note{как язык даже для хобби-программирования,
не говоря о коммерческой разработке}, но и утащили за собой \F\ как подход\ ---
язык, который может написать для себя любой даже самый начинающий программист.

Хочется вернуть ощущение от \F а как от красивой ёлочной игрушки для
программиста, которую можно взять как проект для новогодних каникул. Поэтому в
качестве языка реализации был выбран \py\ --- широко известный, и очень простой
в освоении язык, с наглядным и легко читаемым синтаксимом. Если вам захочется
сделать \textbf{ваш \F} рабочим инструментом, или применить для какой-то задачи,
к вашим услугам будет ведро готовых библиотек на все случаи.

С практической точки зрения, \F\ идеален в качестве интерактивного командного
интерфейса (CLI, shell) для встраиваемых систем на микроконтроллерах, с
подключением по последовательному порту\ --- собственно для этого \F\ изначально
и создавался, с теми же очень ограниченными требованиями к ресурсам. Если вы
занимаетесь автоматизацией, системами сбора данных, или IoT, и этот язык вас
заинтересовал\ --- имея высокоуровневое понимание его устройства, и собственный
опыт его реализации на этом уровне, вы легко сможете сделать и собственную
реализацию для ваших жезезок\note{проще и удобнее всего на базе интерпретатора
байт-кода, на \ci\ (Rust?)}.

Для "традиционных"\ программистов \F\ будет вполне интересен как встраиваемый
языковой движок для написания скриптов и файлов конфигурации. Писать большие
программы на нём слишком сложно, но вот для коротких одностраничных скриптов \F\
вполне удобен.
