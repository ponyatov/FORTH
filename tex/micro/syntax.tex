\clearpage
\secrel{Синтаксис \F а}\label{rstack}\secdown

\noindent
\F\note{англ. Forth, FORTH, 4th}\ --- один из первых конкатенативных языков
программирования:\ref{concat}
\begin{itemize}[nosep]
    \item программа состоит из последовательности \term{слов}, разделенных
    пробелами\note{включая табуляции и концы строк}: группа любых непробельных
    символов является словом
    \item частный случай слов\ --- целочисленные литералы\note{запись чисел}; по
    стандарту классического \F а поддержка чисел с плавающей точкой необязательна
    \item параметры для слов, результаты их выполнения, и промежуточные данные
    передаются через общий \term{стек данных}
    \item математические выражения не поддерживаются, и реализуются через
    постфиксную запись, и манипуляции с вершиной стека.
\end{itemize}

Несколько примеров для понимания (\verb|gforth|, интерактивная
REPL-сессия\note{Read-Eval-Print-Loop} ):

\begin{verbatim}
> 1 2 + [Enter] ok
> _
\end{verbatim}

Результат не выводится, так как он находится в стеке. Для вывода верхнего
элемента в стеке классического \F а используется слово \verb|.| (точка):
\begin{verbatim}
> . [Enter] 3 ok
\end{verbatim}

Для вывода состояния стека также можно использова слово \verb|S.|
\begin{verbatim}
> 4 5 6 S. [Enter] <3> 4 5 6 ok
\end{verbatim}
    

\clearpage
\paragraph{Работа пошагово:}
\begin{description}
    \item[1] \verb|( -- int:1 )| распознается как число, кладётся на вершину стека
    \item[(...)] \term{стековая нотация}\\
    в \F е блочный комментарий начинается со слова \verb|(| (скобка)\\
    слово \verb|(| \emph{запускается}, и пропускает символы во \term{входном
    потоке}\ref{instream}\ пока не встретит закрывающую скобку \verb|)|
\end{description}
    

\clearpage
\secrel{Конкатенативный язык}\label{concat}

\F\ относится к довольно узкому классу \term{конкатенативных} языков.

\begin{itemize}[nosep]
    \item \href{http://bit.ly/3924nEu}{Конкатенативный язык программирования}
    \item \href{https://stackoverflow.com/a/907336}{Explain concatenative
    languages to me like I'm an 8-year-old}
\end{itemize}

\begin{itemize}
    \item В большинстве обычных языков программирования у вас есть переменные,
    которые вы можете свободно определять, а также использовать как
    \term{аргументы функций}.
    \item Конкатенативный язык использует жёстко заданную структуру данных для
    сохранения параметров и передачи результата вычисления функций (обычно стек,
    иногда список). Переменные не обязательны\ --- передача данных работает
    через это общую структуру.
    \item Все функции, и даже просто отдельные куски кода, имеют один и тот же
    интерфейс для обмена данными\ --- они работают с тем, что осталось на стеке
    до их вызова, и оставляют результат своего вычисления там же.
    \item Часто используется и \term{гомоиконичность}: сам \textbf{код является
    данными}, то есть код может менять сам себя, или принимать другой код в
    качестве параметра на стеке, и трансформировать его с помощью штатных
    операций преобразования структур данных.
\end{itemize}

Эти особенности деляют конкатенативный язык удобным для применения подхода с
выстраиванием цепочек из уже готового кода для получения новых возможностей.
\term{Повторное использование кода} является неотделимым свойством такого языка.
Например, вы можете определить функцию, которая берёт со стека любой кусок кода,
и список, и применяет полученный код к каждому элементу списка. Причем эта
функция может работать с любыми данными, ведущими себя как список: результатами
запроса в СУБД, строка пикселов изображения, символы в строке, и т.п.

Самая большая проблема c конкатенативными языками заключается в том, что вы не
понимаете, что происходит, глядя только на исходный код. Цепочка запуска может
быть построена для любых фрагментов кода, и при этом синтаксис не отображает
происходящего с данными на стеке\note{в \F е для этого очень рекомендуется
использовать специальную запись \term{стековых комментариев}, в которых
указываются элементы данных на стеке в текущей точке программы, или до и после
выполнения фрагмента кода}. Чужой код (слишком часто) можно понять только
выполняя его пошагово в отладчике, или командной строке. Соответственно, для
работы с такими языками нужна некоторая привычка, определённые
приёмы\note{написание стековых комментариев, выделение кода в изолированные
фрагменты с заданным поведением}, и подходящие инструменты\note{удобный
интерактивный отладчик}.

\clearpage
\secrel{Входной поток}\label{instream}

\secup

